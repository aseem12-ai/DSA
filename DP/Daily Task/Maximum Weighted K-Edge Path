https://leetcode.com/problems/maximum-weighted-k-edge-path/description/



class Solution {
public:
    // static int dp[301][301][3001];
    int dfs(int node,int k,int sum,int t,unordered_map<int,vector<pair<int,int>>> &adj,vector<vector<unordered_map<int,int>>> & memo){
        if(k==0) return sum<t?sum:-1;
        if(memo[node][k].count(sum)) return memo[node][k][sum];
        int maxSum=-1;
        for(auto &[neighbour,weight]:adj[node]){
            int newSum=sum+weight;
            if(newSum>t) continue;
            int result=dfs(neighbour,k-1,newSum,t,adj,memo);
            if(result!=-1){
                maxSum=max(maxSum,result);
            }
        }
        return memo[node][k][sum]=maxSum;
    }
    int maxWeight(int n, vector<vector<int>>& edges, int k, int t) {
        
        unordered_map<int,vector<pair<int,int>>> adj;
        for(auto &e:edges){
            int u=e[0],v=e[1],w=e[2];
            adj[u].push_back({v,w});
        }
        
        vector<vector<unordered_map<int,int>>> memo(n,vector<unordered_map<int,int>>(k+1));
        int ans=-1;
        for(int i=0;i<n;i++){
            int res=dfs(i,k,0,t,adj,memo);
            ans=max(ans,res);
        }

        return ans;
        
    }
};
